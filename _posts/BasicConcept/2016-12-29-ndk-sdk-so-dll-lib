---
layout: life
category : C++
duoshuo: true
date: 2016-12-29
title: SDK ,NDK,lib,dll,.so,.a (转)
---

	作者: MrZhong
	时间: 2016年12月29日
	版本: 0.0.1

-----------

http://www.cnblogs.com/LoongEmbedded/p/5298394.html

1.     SDK

Android SDK(AndroidSoftware Development Kit)，即Android软件开发工具包，Android的SDK基于Java实现，这意味着基于Android SDK进行开发的第三方应用都必须使用Java语言。但这并不等同于“第三方应用只能使用Java”，也就是说我们还可以采用C/C++语言。

Android SDK主要包括开发文档、编译工具等等，其主要目录如下:

(1)  Build-tools

保存着一些编译工具，比如aapt、aidl、dx等文件。

(2)  Extras

一些Android的支持库、Google的工具等。

(3)  Platforms

是每个平台的SDK真正的文件，里面会根据API level划分SDK版本，这里以Android4.4来说，进入后有一个android-19文件夹，里面的data主要包含资源文件和字体文件等；skins主要包含Android模拟器的皮肤；templates是工程承建的默认模板；android.jar则是该版本的主要framework文件。

(4)  Platform-tools

包含一些调试工具，比如adb、fastboot等。

(5)  Samples

是Android SDK自带的默认示例工程。

(6)  System-images

包含有Android模拟器需要的系统文件，有kernel-qmemu(内核文件)、ramdisk.img(文件系统)、userdata.image(包含应用及用户相关数据)和system.img(Android操作系统文件)。

(7)  Temp

用于存放一些临时文件，比如下载文件时保存下载下来的包。

(8)  Tools

这里包含了重要的工具，比如ddms是用于启动Android调试工具， draw9patch则是绘制android平台的可缩放png图片的工具，sqlite3可以在PC上操作SQLite数据库，而monkeyrunner则是一个不错的压力测试应用，模拟用户随机按键，mksdcard则是模拟器SD映像的创建工具，emulator是Android SDK模拟器主程序，不过从android 1.5开始，需要输入合适的参数才能启动模拟器，traceview作为android平台上重要的调试工具。

2.     NDK

2.1   什么是NDK

 
NDK即Native Development Kit，众所周知，Android程序运行在Dalvik虚拟机中，NDK允许用户使用类似C / C++之类的原生代码语言执行部分程序。

NDK是一系列工具的集合。它提供了一系列的工具，帮助开发者快速开发C（或C++）的动态库，并能自动将so和java应用一起打包成apk(AndroidPackage的缩写，Android安装包)。这些工具对开发者的帮助是巨大的。它集成了交叉编译器，并提供了相应的mk文件隔离CPU、平台、ABI等差异，开发人员只需要简单修改mk文件（指出“哪些文件需要编译”、“编译特性要求”等），就可以创建出so。它可以自动地将so和Java应用一起打包，极大地减轻了开发人员的打包工作

NDK提供了一份稳定、功能有限的API头文件声明，Google明确声明该API是稳定的，在后续所有版本中都稳定支持当前发布的API。从该版本的NDK中看出，这些API支持的功能非常有限，包含有：C标准库（libc）、标准数学库（libm）、压缩库（libz）、Log库（liblog）。

2.2   为什么使用NDK

(1)  代码的保护。由于apk的java层代码很容易被反编译，而C/C++库反汇难度较大。

(2)  可以方便地使用现存的开源库。大部分现存的开源库都是用C/C++代码编写的。

(3)  提高程序的执行效率。将要求高性能的应用逻辑使用C开发，从而提高应用程序的执行效率。

(4)便于移植。用C/C++写得库可以方便在其他的嵌入式平台上再次使用。


图1


3.     JNI

JNI是Java Native Interface的缩写，中文为JAVA本地调用。从Java1.1开始，Java Native Interface(JNI)标准成为java平台的一部分。


JNI是java语言提供的Java和C/C++相互沟通的机制，Java可以通过JNI调用本地的C/C++代码，本地的C/C++的代码也可以调用java代码。JNI 是本地编程接口，Java和C/C++互相通过的接口。Java通过C/C++使用本地的代码的一个关键性原因在于C/C++代码的高效性。


4.    so文件

即使第三方应用开发者使用JNI完成了自己的C动态链接库（so）开发

NDK编译C/C++源代码文件生成动态链接库so，android系统编译生成的so文件放在\out\target\product\prj\system\lib目录下。


5.什么是lib，什么是dll，什么是.a，什么是.so，什么是静态库，什么是动态库

所谓静态库，就是在静态编译时由编译器到指定目录寻找并且进行链接，一旦链接完成，最终的可执行程序中就包含了该库文件中的所有有用信息，包括代码段、数据段等。所谓动态库，就是在应用程序运行时，由操作系统根据应用程序的请求，动态到指定目录下寻找并装载入内存中，同时需要进行地址重定向。 win32平台下，静态库通常后缀为.lib，动态库为.dll linux平台下，静态库通常后缀为.a，动态库为.so 从本质上来说，由同一段程序编译出来的静态库和动态库，在功能上是没有区别的。不同之处仅仅在于其名字上，也就是“静态”和“动态”。 由上面的介绍不难看出，相对于动态库，静态库的优点在于直接被链接进可执行程序中，之后，该可执行程序就不再依赖于运行环境的设置了（当然仍然会依赖于 CPU指令集和操作系统支持的可执行文件格式等硬性限制）。而动态库的优点在于，用户甚至可以在程序运行时随时替换该动态库，这就构成了动态插件系统的基础。 具体使用静态库和动态库，由程序员根据需要自己决定。

另外，需要说明的一点是，从底层实现上，动态库的效率可能会比静态库稍差一点点，注意，这里用了“可能”二字，具体差不差，还得看写程序的人。之所以可能会差，主要原因在于，程序总无法直接调用动态库中的函数符号，而只能通过调用操作系统的runtime enviroment接口来动态载入某个函数符号，同时获得该函数符号在内存中的地址，将其保存为函数指针进行调用，这就在函数调用时增加了一次间接寻址的过程。

还是那句话，希望大家都能深入opencv源码库中去，不要仅仅满足于会调几个API，这样很难对自己有提高的。深入进去读源码，看看人家是怎么组织软件架构的，怎么划分模块的。实际上，如果任何一个软件体系的层次模块划分足够清晰和灵活的话，移植性就不会成为很大的问题，无非就是字节对齐、部分算法利用特殊指令集进行优化之类的，这些改动应该仅限于局部调整，而不用全盘重写的。软件架构，很重要的一条就是open-close 原则，要清楚哪些是可变的哪些是不可变的。就像上面，将来会发生变化的算法，就可以考虑放到动态库中，以免将来程序统一全部升级。

另外，在移植软件的过程中，保持接口不变是有多重含义的，我们通常知道的是：

函数、变量名称不变
函数、变量语法属性不变（比如一个声明为C形式的函数，必须以C形式对其进行调用，否则由于重载特性会找不到函数名）
函数返回值类型不变
函数参数个数不变
函数参数类型不变
这里，常常被人们遗忘的，也是最重要的一点是：

保持函数语义不变

这是什么意思，对于一段程序，除了词法分析、语法推导之外，还有很重要的一条就是语义分析。简单来说，对于一个函数，必须保持移植前后，该函数的返回值含义不变、参数含义不变、函数内部行为的外部表现不变。忽视其中任意一条，都会造成上层应用程序的行为变为未定义，从而移植失败。