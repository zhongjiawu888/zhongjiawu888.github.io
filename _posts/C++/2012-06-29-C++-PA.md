---
layout: life
category : C++
duoshuo: true
date: 2012-06-29
title: 千鸟游戏引擎
---

	作者: MrZhong
	时间: 2016年10月1日 modify
	版本: 0.0.2

-----------

## 基于C++

## 3D乒乓球游戏的设计与实现

## 1 背景

毕业实习培训

## 2 千鸟引擎

2.1 游戏引擎概述

游戏引擎是游戏中与具体的游戏无关的核心技术部分，而游戏的部分就是场景和角色模型、动画、声音和代码等其他控制部分。经过游戏业的不断的发展，如今的游戏引擎己经发展为一套由多个子系统共同构成的复杂系统。一般这些引擎都是3D游戏引擎，从建模、动画到光影、粒子特效，从物理系统、碰撞检测到文件管理、网络特性，还有专业的编辑工具和插件，几乎涵盖了开发过程中的所有重要环节。游戏引擎就是游戏开发者们为了降低重复劳动，节省开发时间和开发费用而诞生的，它封装了些在游戏制作中常用的功能，让我们能直接调用这些功能而不用在从头编写。

2.2千鸟引擎

该游戏引擎是一个处理所有事务的系统，它是一个控制模块，向所有的子系统发出命令。因此，需要与每个游戏子系统联系。该游戏引擎也是一个容器，它容纳了其他所有的组件，控制整个系统的各个部分。

该3D游戏引擎实现的功能模块包括：声音控制、输入控制、图形渲染、游戏界面控制等。其中图形渲染是引擎的核心模块，涉及面较广，实现的功能点包括：顶点、纹理、光照、材质、文字、雾化、摄像机、广告牌、动画、粒子特效、地形场景等。最后，使用ICollType接口实现了碰撞检测。

2.2.1 游戏结构

该游戏本质上是一个持续不断的while循环，它执行逻辑，并根据逻辑计算出下一帧图像，并在屏幕上不间断的绘制更新图像。游戏最终表现出来的就是一帧又一帧连续的画面，我们所要作的就是在循环中，不断的获取用户的输入，根据输入执行游戏逻辑，生成下一个游戏动画帧，最后渲染该动画帧。

本引擎中所使用的游戏最基本的流程框架如图1所示

 
			 图1 游戏最基本的流程框架

2.2.2 构成游戏的要素

	1）资源。资源制作分工人员图如图2所示
			   1.也可以成为Asset数据
				2.构成游戏各部件的数据组
				3.美工人员都是使用DCC工具进行制作

 
							图2 资源制作分工人员图

	2）3D模型。3D模型如图3所示

 
图3  3D模型图

3）执行文件。执行文件如图4所示

			   	1.驱动游戏内容的引擎

				2.所有一切从游戏访问这个文件开始

				3.程序员在文本文件中创建源代码

 
							图4	 执行文件图

4）游戏引擎的构成与使用者的关系。游戏引擎的构成与使用者的关系如图5所示
 


						图5  游戏引擎的构成与使用者的关系图

2.2.3 引擎各模块之间的协同操作

	引擎各模块之间的协同操作如图6所示 

						图6  引擎各模块之间的协同操作
##3 游戏策划与实现
 
	3.1.1  项目介绍

	3.1.1.1 游戏的简要介绍

这是一款操作简单的3D乒乓球游戏，游戏中你可以选择喜爱的国家参加比赛，通过移动画面上球拍的位置，从不同角度击回对方打过来的乒乓球。该款游戏的画面较为简洁，游戏自始至终停留在一个“三维”的平面中，给人一种空间意识。该游戏没许多的音效，当乒乓球撞击到自己和对方的球拍，或者球桌时，会有撞击响声，赢球后有观众的欢呼声，在进入游戏时有背景音乐，并可设置开关。整体上是一款非常不错的休闲体育类游戏。

3.1.2 项目概述
					
					项目概述如表1所示

项目名称：	3D乒乓球游戏	开发平台：	PC平台
游戏类型：	体育类	屏幕尺寸：	1280*720
开发工具：	Microsoft Visual Studio 2008
预计开发周期：	60天	游戏风格概述：	现实再现
适合玩家群体：	适合所有玩家群体
上手难度：	上手容易，上手时间在2分钟

								表1  项目概述表

3.1.3 游戏进度表

项目开发进度预估列表

项目名称	开发阶段	任务分配	项目版本	所需时间

3D乒乓球游戏

1、前期策划	前期策划和项目规划		1～2天

2、Model制作	所有需要的Model设计阶段		2～3天

3、设计主要类	文件类，打球类，音效类…	Alpha版本	5～7天

4、主菜单实现	游戏的进入，返回	Alpha版本	3～5天

5、加载Model	所有模型的加载	Alpha版本	1～2天

6、场景旋转	3D效果	Alpha版本	2～3天

7、打球实现	球的轨迹，碰撞	Alpha版本	7～10天

8、音效实现	背景音乐实现	Bate版本	5～7天

9、代码优化	提高游戏运行效率，调试	Release版本	8～10天

阶
段	项目前期准备，策划日期：3/1～3/5
项目Alpha版本日期：3/6～3/31
项目Bata版本日期：4/1～4/20
项目Release版本日期：4/21～5/1
表2  项目开发进度预估列表

3.1.4 游戏WBS设计
 
 
 
								图7   WBS图
3.1.5 游戏美工需求表

 
表3  美工需求表

3.1.6 游戏运行环境

	Windows 64位 并有千鸟引擎程序库环境

3.2 游戏实现

3.2.1  游戏流程图
 
图8 流程图

3.2.2 游戏的实现及相关概念

游戏的实现主要包括了3D模型与动画（Motion）的构造、对镜头的操作、碰撞网格的检测、音效的载入、乒乓球运动的轨迹的实现。

1.	3D模型与动画（Motion）的构造

游戏中涉及到的3D模型主要是场地、球桌、球拍、球。千鸟引擎中使用的模型图片格式是.pmd,由3DMaya制图工具导出（具体转化流程如图9所示）。
 
图9  3D模型格式转化流程图

在程序中描绘出模型，需要先生成CModel class 的 Instance,把Model File 的内容写入Buffer,使用CModel::loadFromBuffer()将写入Buffer中所需data复制给各个member,然后在update()中更新，最后在CModel::render()中绘制画面。
模型的移动要使用到CTransform类，该类负责控制Model的姿势。

2. 镜头的操作

从开始进入游戏到在游戏过程中对球桌的操作都使用到了镜头的操作。在千鸟引擎中，镜头的主要要素有Camera Location,Camera Interest(注视点).要在显示器显示，需要将3维的模型图形转化为二维的图形。
镜头的控制使用的类是CGraphicDevice 的 instance.创建实例：

CGraphicDevice * pGevice=CGraphiceMan::getInstance()->getCurrentDevice().使用CgraphicDevice ::setCameraEye()可以将镜头位置的向量（vector）赋给参数，使用CGraphicDevice::setCameraInterest()，可以视角位置的向量（vector）赋给参数。

2.	碰撞网格的检测

游戏中运用到碰撞主要是乒乓球与球桌、球拍以及球网上。在3D模型制作时，需用碰撞网格（CollisionMesh）完全包裹住模型，以提供判断模型是否碰撞的网格数据。
碰撞检测类必须实现ICollType接口，球体类可继承CCollSphere,球桌和球网以及球拍可视为长方体，因此可继承CCollBoxAABB类即可。CTransform类决定了碰撞对象的位置和角度，给碰撞对象传递一个Ctransform指针使用。代码如下：

	CTransform transform; 
	ICollType* pColl = ****; 
	pColl->setTransform( &transform ); 
	transform.setTranslate( CVector4( 100.f, 50.f, -40.f ) );
	CCollSphere的使用方法：用函数setRadius()

设置半径，用transform改变状态,代码如下：

	CTransform transform;
	CCollSphere sphere( NULL, &transform ); //将半径设成20 sphere.setRadius( 20.f ); //球体的中心设成( 10, -10, 0 ) transform.setTranslate( CVector4( 10.f, -10.f, 0.f ) );

CCollBoxAABB的使用方法：用函数setDimension()

设置半径，用transform改变状态,代码如下：

	CTransform transform;
	CCollBoxAABB aabb( NULL, &transform ); 
	aabb.setDimension( CVector4( 40.f, 30.f, 20.f ) ); transform.setTranslate( CVector4( 10.f, -10.f, 0.f ) );

	CCollMesh的使用方法：使用函数getCollision()或者函数findCollision(),从Cmodel中获取作为ICollType*的网格，代码如下：

	//获取CollisionMesh的数量 
	uint32 nMeshuNum = pModel->getCollisionMeshNumber(); 
	//获取CollisionMesh 
	CCollisionMesh* pMesh = Model->getCollisionMesh( index );

碰撞测试则使用函数isCheckType(),代码如下：

	CTransform trA,trB; //含有碰撞网格的模型 
	CModel* pModel = ****; //也可以用构造函数设置transform ICollType* pCollA = new CCollSphere( NULL, &trA ); ICollType* pCollB = new CCollMesh( pModel, &trB ); CVector4 vHitPos; bool isHit = CollA->isCheckColl( pCollB, vHitPos );

3.	音效的载入

音效的作业流程如图10所示， 

图10   音效的作业流程

	
要在程序中加载音效，需要实现Sound类，该类的实例由Application持有，核心代码如下：
		//初始化
		int Application::init(){ 
		・・・ 
		m_pSound = new Sound();
		Sound::SCreateInfo info;
		 m_pSound->initialize( info ); 
		・・・ }
		Sound& Application::getSound() {
		return *m_pSound; }

		//数据登录
		Sound::setSETable( SmartPointer<void> ) //登录SE的表格数据
		Sound::registGroup( uint32, SmartPointer<void>) //在音效（Sound）用的缓存中登录音源数据,第一参数为群组编号
					
		//音效播放
		SoundProxy proxy = getApp()->getSound().play( 0 );//暂停 
		PROXY.PAUSE( ); //由暂停处开始继续播放 
		PROXY.REPLAY();//停止 
		PROXY.STOP( 0.5F );//获取现在的音效状态 
		STATE() ; (ISOUND::PLAY : 播放中, ISOUND::PAUSE :暂停中)

4.	球的轨迹分析

1)	自由落体运动

详细分析：
物体在只受重力作用下，由高空自由下落。

a.受力：
只受到自身重力，大小为 物体质量×重力加速度。

b.速度：
由于受到重力作用，物体会做初速度为0，加速度为g的匀加速直线运动。
则：末速度 = 重力加速度 × 时间，即Vt = gt 
当前位移 = 上一秒位移 + 当前速度,即St = So + Vt 
物体在任意时刻的速度和位移就可通过以上公式求出。
现实中我们使用的位移单位是m，时间单位是s，转换代码需要将位移单位看做单位坐标，时间单位看做程序每一帧运行的时间。

 
图11 自由落体受力分析图

2) 球的弹性

详细分析：

	a.受力：
	假设球与地面做完全弹性碰撞，碰撞前后系统动能守恒，没有能量损失。
	球于地面发生碰撞分为两个阶段：
	压缩阶段：球与地面开始碰撞时，球体发生形变，由形变实际上弹性恢复力使两球的速度发生变化，直到球的速度减为0。
	恢复阶段：由于形变仍然存在，弹性恢复力继续作用，使球的速度发生改变。
	b.速度：
	从压缩状态开始，到恢复状态结束，y轴方向的速度反向。

3)	抛物线运动

抛物线运动是物体在y轴上做自由落体运动，而在x轴和z轴做匀速直线运动（若考虑空气阻力，就是做匀减速直线运动)。
抽象成代码:

BallPosition.x += BallVelocity.x;
BallPosition.z += BallVelocity.z; 
 
图12  抛物线受力分析图

4)	 能量损耗

物体在运动中会与空气与地面发生摩擦产生内能，发生机械能的损耗。
物体低速运动时与空气摩擦，空气对物体的阻力的大小和物体的速度大小成正比。即会随着物体速度的不断增大，使物体的加速度不断减小。
抽象成代码：
a += k * BallVelocity;		//k为自己定义的任意常量
g += a;			//a的方向总与速度方向相反
地面碰撞的情况与此类似。


3.3  游戏相关界面

![](/images/studyRes/20.png)

![](/images/studyRes/21.png)

![](/images/studyRes/22.png)

![](/images/studyRes/23.png)

![](/images/studyRes/24.png)

## 4 总结

  经过在公司6个多月的不断努力,项目已经基本完成，毕业设计内容也告一段落。回顾这个设计过程,学到了许多书本上没有学到的知识。通过这次自己开发的游戏,丰富了自己的实践技能,扩展了本专业的知识面,使我受益非浅,同时也体验到了做软件开发的困难度。在这次设计的同时,又从中学到了许多东西。但由于我对这样的软件开发还只是一个开始，了解的不多，这其中或许还有很多的不足，有些模块做得不是很好，有些功能还不能够完全的实现，如球的落点设计是随机的，因此轨迹显得并不太真实，以及AI不够智能，还待完善，界面的设计及整体的布局还比较简单，没有突出特色出来，这也可能是我这个系统的不足之处，在这里也恳请各位老师能够对我的作品指明不足并加以改正。

  总的来说，自认为还是比较自豪的，因为这是大学来完成的一个比较全面的项目，从项目前期的游戏策划，美工需求素材的制作，流程图及WBS的设计，到后期的游戏的设计，代码的实现等，使我体会到了，制作一个游戏所需要做的工作，每一个环节都占据着重要的位置，影响着游戏的质量。

  最后，在此我很感谢[江西腾王科技有限公司](http://www.tenone.cn/)及其合作伙伴日本PA公司，提供给我一个非常难得的培训实习机会，使我能有开发一个完整项目的锻炼机遇，非常非常感谢十野晃一老师在期间对我们的培训教学，以及其公司强大的技术支持，还有我的团队组员何亚标与杨飘平同学，在项目开发中遇到的大大小小的难题时，给予我莫大的鼓励和帮助，从而使得这次毕业设计顺利完成，也为我的大学生活画上一个圆满的句号。

**************

